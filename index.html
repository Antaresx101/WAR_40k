<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Warhammer Ability Reference - 40k : Organize and manage your army abilities">
    
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WAR_40k">
    
    <title>Warhammer Ability Reference - 40k</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;700&family=Exo+2:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="./assets/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="./assets/icon-512.png">
    <link rel="apple-touch-icon" href="./assets/icon-192.png">
    
    <style>
        /* ==================== BASE STYLES ==================== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        :root {
            --primary: #3a5b8de1;
            --primary-dark: #e6eaec;
            --secondary: #e6eaec;
            --menu: #3a5b8d7a;
            --menu-dark: #42c2e2;
            --accent: #42c2e2;
            --success: #48bb78;
            --warning: #ed8936;
            --danger: #f56565;
            --info: #4299e1;
            
            --bg-light: #ffffff;
            --bg-light-alt: #f7fafc;
            --text-light: #2d3748;
            --text-light-secondary: #4a5568;
            --border-light: #e2e8f0;
            
            --bg-dark: #1a202c;
            --bg-dark-alt: #2d3748;
            --text-dark: #e2e8f0;
            --text-dark-secondary: #cbd5e0;
            --border-dark: #4a5568;
            
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        
        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            min-height: 100vh;
            color: var(--text-light);
            transition: background 0.3s ease;
            overflow-x: hidden;
        }
        
        body.dark-mode {
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-dark-alt) 100%);
            color: var(--text-dark);
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        /* ==================== LAYOUT ==================== */
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: white;
            box-shadow: var(--shadow);
            padding: 5px 15px;
        }
        
        body.dark-mode .header {
            background: var(--bg-dark-alt);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        
        .app-title {
            font-size: clamp(0.8rem, 4vw, 1.2rem);
            font-weight: 700;
            font-family: 'Orbitron', 'Rajdhani', 'Exo 2', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
            text-transform: uppercase;
        }

        body.dark-mode .app-title {
            background: linear-gradient(135deg, var(--menu-dark) 0%, var(--menu) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .content {
            flex: 1;
            padding: 10px;
            background: var(--bg-light);
        }
        
        body.dark-mode .content {
            background: var(--bg-dark);
        }
        
        /* ==================== BUTTONS ==================== */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .action-btn:active {
            transform: translateY(0);
            background: var(--primary);
            color: white;
        }
        
        body.dark-mode .action-btn:active {
            background: var(--accent);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .btn-primary {
            background: var(--menu);
            color: white;
        }
        
        .btn-secondary {
            background: var(--bg-light-alt);
            color: var(--text-light);
        }

        body.dark-mode .btn-primary {
            background: var(--menu-dark);
            color: white;
        }

        body.dark-mode .btn-secondary {
            background: var(--bg-dark-alt);
            color: var(--text-dark);
        }
        
        .btn-icon {
            padding: 10px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* ==================== WELCOME SCREEN ==================== */
        .welcome-screen {
            text-align: center;
            padding: 10px 20px;
        }
        
        .welcome-screen h2 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            margin-bottom: 20px;
            color: var(--text-light);
        }
        
        body.dark-mode .welcome-screen h2 {
            color: var(--text-dark);
        }
        
        .welcome-screen p {
            font-size: 1.1rem;
            margin-bottom: 30px;
            color: var(--text-light-secondary);
        }
        
        body.dark-mode .welcome-screen p {
            color: var(--text-dark-secondary);
        }
        
        .upload-area {
            background: white;
            border: 3px dashed var(--border-light);
            border-radius: 8px;
            padding: 10px;
            margin: 20px auto;
            max-height: 200px;
            max-width: 500px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        body.dark-mode .upload-area {
            background: var(--bg-dark-alt);
            border-color: var(--border-dark);
        }
        
        .upload-area:hover {
            border-color: var(--primary);
            background: var(--bg-light-alt);
        }
        
        body.dark-mode .upload-area:hover {
            background: var(--bg-dark);
        }
        
        .upload-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }
        
        .file-input {
            display: none;
        }
        
        .saved-lists {
            margin-top: 0px;
        }
        
        .saved-lists h3 {
            margin-bottom: 15px;
            color: var(--text-light);
        }
        
        body.dark-mode .saved-lists h3 {
            color: var(--text-dark);
        }
        
        .list-card {
            background: white;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .saved-lists h3 {
            color: var(--text-dark);
        }
        
        body.dark-mode .list-card {
            background: var(--bg-dark-alt);
        }
        
        .list-card:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow-lg);
        }
        
        .list-info h4 {
            margin-bottom: 5px;
            text-align: left;
            color: var(--primary);
        }

        body.dark-mode .list-info h4 {
            color: var(--primary-dark);
        }

        .list-info p {
            font-size: 0.9rem;
            text-align: left;
            color: var(--text-light-secondary);
        }
        
        body.dark-mode .list-info p {
            color: var(--text-dark-secondary);
        }
        
        .list-actions {
            display: flex;
            gap: 10px;
        }
        
        /* ==================== ARMY VIEW ==================== */
        .army-header {
            background: white;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .army-header {
            background: var(--bg-dark-alt);
        }
        
        .army-header h2 {
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        body.dark-mode .army-header h2 {
            color: var(--accent);
        }
        
        .army-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            color: var(--text-light-secondary);
        }
        
        body.dark-mode .army-meta {
            color: var(--text-dark-secondary);
        }
        
        .stats-panel {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.3rem;
            font-weight: 800;
        }
        
        .stat-label {
            font-size: 0.75rem;
            opacity: 0.9;
            margin-top: 2px;
        }
        
        /* ==================== SEARCH & FILTER ==================== */
        .controls-bar {
            background: white;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .controls-bar {
            background: var(--bg-dark-alt);
        }
        
        .search-box {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--border-light);
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 8px;
            transition: border-color 0.3s;
        }
        
        .search-box:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        body.dark-mode .search-box {
            background: var(--bg-dark);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }
        
        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 8px 16px;
            border: 2px solid var(--border-light);
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            font-size: 14px;
        }
        
        .filter-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        body.dark-mode .filter-btn {
            background: var(--bg-dark);
            border-color: var(--border-dark);
            color: var(--text-dark);
        }
        
        body.dark-mode .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        /* ==================== PHASE SECTIONS ==================== */
        .phase-section {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 5px solid var(--primary);
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .phase-section {
            background: var(--bg-dark-alt);
        }
        
        .phase-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        body.dark-mode .phase-section h3 {
            color: var(--accent);
        }
        
        /* ==================== ABILITIES ==================== */
        .ability {
            position: relative;
            background: var(--bg-light-alt);
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid var(--info);
            transition: all 0.2s ease;
            cursor: grab;
        }
        
        .ability:active {
            cursor: grabbing;
        }
        
        .ability:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow);
        }
        
        .ability.dragging {
            opacity: 0.5;
        }
        
        .ability.enemy {
            border-left-color: var(--danger);
            background: linear-gradient(90deg, #fff5f5 0%, var(--bg-light-alt) 100%);
        }
        
        .ability.stratagem {
            border-left-color: var(--warning);
        }
        
        .ability.detachment {
            border-left-color: var(--secondary);
        }
        
        body.dark-mode .ability {
            background: var(--bg-dark);
        }
        
        body.dark-mode .ability.enemy {
            background: linear-gradient(90deg, #2d1b1b 0%, var(--bg-dark) 100%);
        }
        
        .ability-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .ability:hover .ability-controls {
            opacity: 1;
        }
        
        .ability-controls button {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            background: white;
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .ability-controls button {
            background: var(--bg-dark-alt);
        }
        
        .ability-controls button:hover {
            transform: scale(1.1);
        }
        
        .ability-controls .color-btn:hover { background: var(--success); }
        .ability-controls .duplicate-btn:hover { background: var(--info); }
        .ability-controls .edit-btn:hover { background: var(--warning); }
        .ability-controls .delete-btn:hover { background: var(--danger); color: white; }
        
        .unit-name {
            font-weight: 700;
            color: var(--text-light);
            font-size: 1.1rem;
            margin-bottom: 5px;
            padding-right: 50px;
        }
        
        body.dark-mode .unit-name {
            color: var(--text-dark);
        }
        
        .ability-name {
            font-style: italic;
            color: var(--primary);
            font-size: 1rem;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        body.dark-mode .ability-name {
            color: var(--accent);
        }
        
        .ability-desc {
            color: var(--text-light-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-line;
        }
        
        body.dark-mode .ability-desc {
            color: var(--text-dark-secondary);
        }
        
        .ability-desc strong {
            color: var(--text-light);
            font-weight: 700;
        }
        
        body.dark-mode .ability-desc strong {
            color: var(--text-dark);
        }
        
        .ability-keywords {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-light);
            font-size: 0.8rem;
            color: var(--text-light-secondary);
            font-style: italic;
        }
        
        body.dark-mode .ability-keywords {
            border-top-color: var(--border-dark);
            color: var(--text-dark-secondary);
        }
        
        /* ==================== PHASE NAVIGATION ==================== */
        .phase-nav {
            background: white;
            border-radius: 6px;
            padding: 8px 10px;
            margin-bottom: 10px;
            box-shadow: var(--shadow);
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        body.dark-mode .phase-nav {
            background: var(--bg-dark-alt);
        }
        
        .phase-nav-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-light);
            background: var(--bg-light-alt);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            text-decoration: none;
            color: var(--text-light);
        }
        
        .phase-nav-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .phase-nav-btn:active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        body.dark-mode .phase-nav-btn {
            background: var(--bg-dark);
            border-color: var(--border-dark);
            color: var(--text-dark);
        }
        
        body.dark-mode .phase-nav-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        body.dark-mode .phase-nav-btn:active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        /* ==================== MODAL ==================== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 25px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
        }
        
        body.dark-mode .modal-content {
            background: var(--bg-dark-alt);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h3 {
            color: var(--primary);
        }
        
        body.dark-mode .modal-header h3 {
            color: var(--accent);
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light-secondary);
        }
        
        body.dark-mode .close-modal {
            color: var(--text-dark-secondary);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-light);
        }
        
        body.dark-mode .form-group label {
            color: var(--text-dark);
        }
        
        .form-group select,
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border-light);
            border-radius: 5px;
            font-size: 14px;
            font-family: inherit;
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }
        
        body.dark-mode .form-group select,
        body.dark-mode .form-group input,
        body.dark-mode .form-group textarea {
            background: var(--bg-dark);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }
        
        /* ==================== NOTES ==================== */
        .notes-panel {
            background: white;
            border-radius: 6px;
            padding: 6px;
            margin: 5px 0 10px 0;
            box-shadow: var(--shadow);
        }
        
        body.dark-mode .notes-panel {
            background: var(--bg-dark-alt);
        }
        
        .notes-panel h3 {
            margin-bottom: 15px;
            color: var(--text-light);
        }
        
        body.dark-mode .notes-panel h3 {
            color: var(--text-dark);
        }
        
        .notes-container {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        
        .notes-textarea {
            flex: 0 0 calc(60% - 5px);
            min-height: 75px;
            padding: 6px;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            font-family: inherit;
            resize: vertical;
        }
        
        .exclusion-textarea {
            flex: 0 0 calc(40% - 5px);
            min-height: 75px;
            padding: 6px;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            font-family: inherit;
            resize: vertical;
        }
        
        body.dark-mode .notes-textarea,
        body.dark-mode .exclusion-textarea {
            background: var(--bg-dark);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }
        
        /* ==================== STICKY ACTION BAR ==================== */
        .action-bar {
            background: white;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 8px;
        }
        
        body.dark-mode .action-bar {
            background: var(--bg-dark-alt);
        }
        
        .action-bar-row {
            display: flex;
            gap: 6px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 6px;
        }
        
        .action-bar-row:last-child {
            margin-bottom: 0;
        }
        
        .action-btn {
            padding: 6px 8px;
            border: 1px solid var(--border-light);
            background: var(--bg-light-alt);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            transition: all 0.2s;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: var(--text-light);
        }
        
        .action-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-1px);
        }
        
        body.dark-mode .action-btn {
            background: var(--bg-dark);
            border-color: var(--border-dark);
            color: var(--text-dark);
        }
        
        body.dark-mode .action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        /* Override system dark mode preferences to ensure app's light mode is truly light */
        @media (prefers-color-scheme: dark) {
            /* Force light mode colors when app is NOT in dark mode */
            body:not(.dark-mode) {
                background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-light-alt) 100%) !important;
                color: var(--text-light) !important;
            }
            
            body:not(.dark-mode) .header {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .content {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .btn-secondary {
                background: var(--bg-light-alt) !important;
                color: var(--text-light) !important;
            }
            
            body:not(.dark-mode) .list-card {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .army-header {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .controls-bar {
                background: var(--bg-light-alt) !important;
            }
            
            body:not(.dark-mode) .search-box {
                background: var(--bg-light) !important;
                color: var(--text-light) !important;
                border-color: var(--border-light) !important;
            }
            
            body:not(.dark-mode) .filter-btn {
                background: var(--bg-light) !important;
                border-color: var(--border-light) !important;
                color: var(--text-light) !important;
            }
            
            body:not(.dark-mode) .phase-section {
                background: var(--bg-light-alt) !important;
            }
            
            body:not(.dark-mode) .ability {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .ability-controls button {
                background: var(--bg-light-alt) !important;
            }
            
            body:not(.dark-mode) .modal-content {
                background: var(--bg-light) !important;
            }
            
            body:not(.dark-mode) .form-group input,
            body:not(.dark-mode) .form-group textarea,
            body:not(.dark-mode) .form-group select {
                background: var(--bg-light) !important;
                color: var(--text-light) !important;
                border-color: var(--border-light) !important;
            }
            
            body:not(.dark-mode) .notes-textarea,
            body:not(.dark-mode) .exclusion-textarea {
                background: var(--bg-light) !important;
                color: var(--text-light) !important;
                border-color: var(--border-light) !important;
            }
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 768px) {
            .header-content {
                flex-wrap: nowrap;
                align-items: center;
            }
            
            .app-title {
                font-size: 0.8rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-right: 10px;
            }
            
            .header-actions {
                flex-shrink: 0;
                gap: 5px;
            }
            
            .btn-icon {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
            
            .app-version {
                font-size: 0.7rem;
                margin-right: 5px;
            }
            
            .stats-panel {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            #install-btn {
                font-size: 0.7rem !important;
            }
            
            #install-btn svg {
                width: 0.9em;
                height: 0.9em;
            }

            /* Ensure abilities visibility */
            .phase-section {
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .phase-section h3 {
                font-size: 1.1rem;
                margin-bottom: 10px;
            }
            
            .ability {
                padding: 8px;
                margin-bottom: 8px;
                font-size: 0.9rem;
            }
            
            .ability-name {
                font-size: 0.95rem;
            }
            
            .ability-desc {
                font-size: 0.85rem;
                line-height: 1.4;
            }
            
            .ability-controls {
                top: 5px;
                right: 5px;
            }
            
            .ability-controls button {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
            
            /* Install prompt mobile */
            .install-prompt {
                flex-direction: column;
                text-align: center;
                padding: 15px;
                margin: 10px 5px;
            }
            
            .install-prompt div {
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .install-prompt button {
                width: 100%;
                margin: 5px 0;
            }
            
            /* List card mobile */
            .list-card {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }
            
            .list-actions {
                width: 100%;
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .list-actions .btn {
                flex: 1;
                min-width: 0;
                padding: 6px 8px;
                font-size: 11px;
                text-align: center;
                justify-content: center;
            }
        }
        
        /* ==================== ANIMATIONS ==================== */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .ability {
            animation: slideIn 0.3s ease;
        }
        
        /* ==================== LOADING ==================== */
        .loading {
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            border: 4px solid var(--border-light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* ==================== INSTALL PROMPT ==================== */
        .install-prompt {
            background: linear-gradient(135deg, var(--success) 0%, #38a169 100%);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            margin: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
            animation: slideIn 0.5s ease;
            position: relative;
            z-index: 10;
        }
        
        .install-prompt.hidden {
            display: none;
        }
        
        .install-prompt div {
            flex: 1;
            margin-right: 10px;
        }
        
        .install-prompt strong {
            font-size: 0.9rem;
            display: block;
            margin-bottom: 2px;
        }
        
        .install-prompt p {
            font-size: 0.8rem;
            margin: 0;
            line-height: 1.3;
        }
        
        .install-prompt button {
            background: white;
            color: var(--success);
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.8rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .install-prompt button:hover {
            background: rgba(255, 255, 255, 0.9);
        }
        
        /* ==================== UPDATE BANNER ==================== */
        .update-banner {
            background: linear-gradient(135deg, var(--info) 0%, #3182ce 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
            animation: slideIn 0.3s ease;
        }
        
        .update-banner.hidden {
            display: none;
        }
        
        .update-banner button {
            background: white;
            color: var(--info);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .update-banner button:hover {
            background: rgba(255, 255, 255, 0.9);
        }
        
        /* Update button styling when update is available */
        .btn.update-available {
            background: var(--warning) !important;
            color: white !important;
            border-color: var(--warning) !important;
            animation: pulse-update 2s infinite;
            box-shadow: 0 0 10px rgba(237, 137, 54, 0.5);
        }
        
        .btn.update-available:hover {
            background: #dd7a24 !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(237, 137, 54, 0.7);
        }
        
        @keyframes pulse-update {
            0% {
                box-shadow: 0 0 10px rgba(237, 137, 54, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(237, 137, 54, 0.8);
            }
            100% {
                box-shadow: 0 0 10px rgba(237, 137, 54, 0.5);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1 class="app-title">WAR 40k</h1>
                <div class="header-actions">
                    <span class="app-version" id="app-version" style="font-size: 0.8rem; color: var(--text-light-secondary); margin-right: 10px;"></span>
                    <button class="btn btn-icon btn-secondary" id="add-list-btn" title="Add List from Device (.json)" style="font-size: 1.1rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <button class="btn btn-icon btn-secondary" id="clipboard-import-btn" title="Add List from Clipboard (.json)" style="font-size: 1.1rem; display: none;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            <line x1="9" y1="9" x2="15" y2="9"></line>
                            <line x1="9" y1="13" x2="15" y2="13"></line>
                            <line x1="9" y1="17" x2="13" y2="17"></line>
                        </svg>
                    </button>
                    <button class="btn btn-icon btn-secondary" id="update-btn" title="Check for Updates" style="font-size: 0.9rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M23 4v6h-6"></path>
                            <path d="M1 20v-6h6"></path>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                        </svg>
                    </button>
                <button class="btn btn-icon btn-secondary" id="install-btn" title="Install to Homescreen" style="font-size: 0.9rem;">
                    <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 17v3a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-3"></path>
                        <polyline points="8 12 12 16 16 12"></polyline>
                        <line x1="12" y1="3" x2="12" y2="16"></line>
                    </svg>
                </button>
                    <a href="https://ko-fi.com/antaresx101" target="_blank" rel="noopener noreferrer" class="btn btn-icon btn-secondary" title="Support on Ko-fi" style="font-size: 0.9rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 8h1a4 4 0 0 1 0 8h-1"></path>
                            <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
                            <line x1="6" y1="1" x2="6" y2="4"></line>
                            <line x1="10" y1="1" x2="10" y2="4"></line>
                            <line x1="14" y1="1" x2="14" y2="4"></line>
                        </svg>
                    </a>
                    <button class="btn btn-icon btn-secondary" id="dark-mode-btn" title="Toggle Dark Mode">
                        ðŸŒ—
                    </button>
                </div>
            </div>
        </header>

        <!-- Install Prompt -->
        <div class="install-prompt hidden" id="install-prompt">
            <div>
                <strong>&#128241; Install App</strong>
                <strong>Install App</strong>
                <p>Add to home screen for quick access!</p>
            </div>
            <div>
                <button id="install-btn">Install</button>
                <button id="dismiss-install">Later</button>
            </div>
        </div>

        <!-- Update Banner -->
        <div class="update-banner hidden" id="update-banner">
            <div>
                <strong>ðŸ”„ Update Available!</strong>
                <p style="font-size: 0.9rem; margin-top: 5px;">A new version is ready to install</p>
            </div>
            <button id="update-btn">Update Now</button>
        </div>

        <!-- Content -->
        <main class="content" id="main-content">
            <!-- Welcome Screen -->
            <div id="welcome-screen" class="welcome-screen">
                <div class="sort-controls" style="margin-bottom: 20px; text-align: left;">
                    <button class="filter-btn" onclick="sortLists('name')" data-sort="name">Name</button>
                    <button class="filter-btn" onclick="sortLists('faction')" data-sort="faction">Faction</button>
                    <button class="filter-btn" onclick="sortLists('points')" data-sort="points">Points</button>
                    <button class="filter-btn" onclick="sortLists('date')" data-sort="date">Date</button>
                </div>
                <div class="saved-lists" id="saved-lists-container">
                    <!-- Saved lists will be inserted here -->
                </div>
            </div>

            <!-- Army View (hidden by default) -->
            <div id="army-view" style="display: none;">
                <!-- Army header, stats, controls, and abilities will be inserted here -->
            </div>
        </main>

        <!-- Hidden file input for + button -->
        <input type="file" id="file-input" class="file-input" accept=".json" style="display: none;">
    </div>

    <!-- Add Ability Modal -->
    <div class="modal" id="add-ability-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Custom Ability</h3>
                <button class="close-modal" onclick="closeModal('add-ability-modal')">âœ•</button>
            </div>
            <form id="add-ability-form">
                <div class="form-group">
                    <label>Phase</label>
                    <select id="ability-phase">
                        <option value="DEPLOYMENT / RESERVES">Deployment / Reserves</option>
                        <option value="COMMAND PHASE">Command Phase</option>
                        <option value="MOVEMENT PHASE">Movement Phase</option>
                        <option value="SHOOTING PHASE">Shooting Phase</option>
                        <option value="CHARGE PHASE">Charge Phase</option>
                        <option value="FIGHT PHASE">Fight Phase</option>
                        <option value="ANY PHASE">Any Phase</option>
                        <option value="OTHER">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Unit Name</label>
                    <input type="text" id="ability-unit" required>
                </div>
                <div class="form-group">
                    <label>Ability Name</label>
                    <input type="text" id="ability-name" required>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="ability-desc" required></textarea>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    &#10010; Add Ability
                </button>
            </form>
        </div>
    </div>

    <!-- Edit Ability Modal -->
    <div class="modal" id="edit-ability-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Ability</h3>
                <button class="close-modal" onclick="closeModal('edit-ability-modal')">âœ•</button>
            </div>
            <form id="edit-ability-form">
                <input type="hidden" id="edit-ability-id">
                <div class="form-group">
                    <label>Unit Name</label>
                    <input type="text" id="edit-ability-unit" required>
                </div>
                <div class="form-group">
                    <label>Ability Name</label>
                    <input type="text" id="edit-ability-name" required>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="edit-ability-desc" required></textarea>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    ðŸ’¾ Save Changes
                </button>
            </form>
        </div>
    </div>

    <!-- Stratagem Modal -->
    <div class="modal" id="stratagem-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Stratagems</h3>
                <button class="close-modal" onclick="closeModal('stratagem-modal')">âœ•</button>
            </div>
            <form id="stratagem-form">
                <div class="form-group">
                    <label>Faction URL</label>
                    <input type="url" id="stratagem-url" placeholder="" required>
                    <small style="color: var(--text-light-secondary); margin-top: 5px; display: block;">
                        To be implemented
                    </small>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="include-core-stratagems" style="width: auto; margin-right: 5px;">
                        Include Core Stratagems
                    </label>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Fetch Stratagems
                </button>
                <div id="stratagem-status" style="margin-top: 10px; text-align: center; font-size: 0.9rem;"></div>
            </form>
        </div>
    </div>

    <script>
        // App state and global variables
        const AppState = {
            currentList: null,
            currentListId: null,
            isDarkMode: false,
            deferredPrompt: null,
            draggedElement: null,
            appVersion: '2.0.0' // Changelog
        };

        // Initialize the app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
        });

        function initializeApp() {
            loadDarkMode();
            setupEventListeners();
            loadSavedLists();
            registerServiceWorker();
            setupInstallPrompt();
            
            // Set default sort button state
            const defaultSortBtn = document.querySelector('[data-sort="name"]');
            if (defaultSortBtn) {
                defaultSortBtn.classList.add('active');
            }
        }    
        updateAppVersion();

        // Service worker for PWA functionality
        let newWorker;
        
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => {
                        console.log('Service Worker registered');
                        
                        // Check for updates every 60 seconds
                        setInterval(() => {
                            reg.update();
                        }, 60000);
                        
                        // Detect waiting service worker (update available)
                        reg.addEventListener('updatefound', () => {
                            newWorker = reg.installing;
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available
                                    showUpdateBanner();
                                }
                            });
                        });
                        
                        // Check if there's already a waiting worker
                        if (reg.waiting) {
                            newWorker = reg.waiting;
                            showUpdateBanner();
                        }
                        
                        // Listen for controller change (new SW took over)
                        navigator.serviceWorker.addEventListener('controllerchange', () => {
                            // Reload to get latest version
                            window.location.reload();
                        });
                    })
                    .catch(err => console.log('Service Worker registration failed:', err));
            }
        }
        
        function showUpdateBanner() {
            // Show update button in header with visual indication
            const updateBtn = document.getElementById('update-btn');
            if (updateBtn) {
                updateBtn.style.display = 'block';
                updateBtn.classList.add('update-available');
                console.log('Update available - button highlighted');
            }
        }
        
        function hideUpdateBanner() {
            const updateBtn = document.getElementById('update-btn');
            if (updateBtn) {
                updateBtn.style.display = 'none';
                updateBtn.classList.remove('update-available');
                console.log('Update banner hidden');
            }
        }
        
        // Handle update button click
        document.addEventListener('DOMContentLoaded', () => {
            const updateBtn = document.getElementById('update-btn');
            if (updateBtn) {
                updateBtn.addEventListener('click', () => {
                    if (newWorker) {
                        // Tell the waiting worker to skip waiting and activate
                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                    }
                });
            }
        });

        // App install prompt for PWA
        function setupInstallPrompt() {
            // Check if app is already installed (running as PWA)
            const isInstalled = window.matchMedia('(display-mode: standalone)').matches || 
                               window.matchMedia('(display-mode: minimal-ui)').matches ||
                               document.referrer.includes('android-app://');
            
            console.log('Is app installed?', isInstalled);
            console.log('Service Worker support:', 'serviceWorker' in navigator);
            console.log('Install prompt support:', 'beforeinstallprompt' in window);
            
            // Hide install button by default initially
            const installBtn = document.getElementById('install-btn');
            if (installBtn) {
                installBtn.style.display = 'block';
                console.log('Install button hidden');
            }
            
            // Show install button if not installed and browser supports PWA
            if (!isInstalled && 'serviceWorker' in navigator && 'beforeinstallprompt' in window) {
                console.log('Browser supports PWA install, showing install button');
                if (installBtn) {
                    installBtn.style.display = 'block';
                }
            } else {
                console.log('PWA install not available:', {
                    isInstalled,
                    hasServiceWorker: 'serviceWorker' in navigator,
                    hasInstallPrompt: 'beforeinstallprompt' in window
                });
            }
            
            // Listen for install prompt
            window.addEventListener('beforeinstallprompt', (e) => {
                console.log('beforeinstallprompt event fired');
                e.preventDefault();
                AppState.deferredPrompt = e;
                
                // Show install button in header
                if (installBtn) {
                    installBtn.style.display = 'block';
                    console.log('Install button shown due to beforeinstallprompt event');
                }
            });

            // Handle install button click
            if (installBtn) {
                installBtn.addEventListener('click', async () => {
                    console.log('Install button clicked, deferredPrompt:', AppState.deferredPrompt);
                    if (AppState.deferredPrompt) {
                        AppState.deferredPrompt.prompt();
                        const { outcome } = await AppState.deferredPrompt.userChoice;
                        console.log('Install outcome:', outcome);
                        if (outcome === 'accepted') {
                            console.log('App was installed');
                            installBtn.style.display = 'none';
                        }
                        AppState.deferredPrompt = null;
                    } else {
                        console.log('No install prompt available');
                        alert('App installation is not available in this browser. Try using Chrome, Edge, or Firefox on desktop/mobile.');
                    }
                });
            }
        }

        // Set up all event listeners
        function setupEventListeners() {
            // Dark mode toggle
            document.getElementById('dark-mode-btn').addEventListener('click', toggleDarkMode);

            // Add list button (file explorer only)
            document.getElementById('add-list-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Clipboard import button - IMPLEMENT (read from clipboard not working)
            document.getElementById('clipboard-import-btn').addEventListener('click', async () => {
                try {
                    // Try to read from clipboard (check for files first)
                    if (navigator.clipboard && navigator.clipboard.read) {
                        try {
                            const clipboardItems = await navigator.clipboard.read();
                            
                            // Look for JSON files in clipboard
                            for (const item of clipboardItems) {
                                for (const type of item.types) {
                                    if (type === 'application/json' || type.endsWith('.json')) {
                                        const blob = await item.getType(type);
                                        const text = await blob.text();
                                        const jsonData = JSON.parse(text);
                                        
                                        // Basic validation to check if it looks like an army list
                                        if (jsonData && (jsonData.faction || jsonData.abilities || jsonData.name)) {
                                            await processFileData(jsonData);
                                            return;
                                        } else {
                                            alert('No valid army list data found in clipboard file. Please copy a valid JSON army list file.');
                                            return;
                                        }
                                    }
                                }
                            }
                            
                            // If no JSON files found, check for text content as fallback
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                const clipboardText = await navigator.clipboard.readText();
                                console.log('Clipboard text length:', clipboardText.length);
                                
                                // Check if clipboard has content before parsing
                                if (!clipboardText || clipboardText.trim() === '') {
                                    console.log('Clipboard is empty');
                                    alert('Clipboard is empty. Please copy a valid JSON army list file or text.');
                                    return;
                                }
                                
                                // Check if clipboard contains valid JSON
                                try {
                                    const jsonData = JSON.parse(clipboardText);
                                    
                                    // Basic validation to check if it looks like an army list
                                    if (jsonData && (jsonData.faction || jsonData.abilities || jsonData.name)) {
                                        // Import from clipboard directly
                                        await processFileData(jsonData);
                                        return;
                                    } else {
                                        console.log('Invalid army list data structure:', jsonData);
                                        alert('No valid army list data found in clipboard. Please copy a valid JSON army list file or text.');
                                    }
                                } catch (jsonError) {
                                    console.error('Clipboard text error:', jsonError);
                                    console.error('Clipboard content preview:', clipboardText.substring(0, 200));
                                    alert('Invalid JSON in clipboard. Please copy a valid JSON army list.');
                                }
                            } else {
                                alert('No JSON file found in clipboard. Please copy a valid JSON army list file to clipboard.');
                            }
                            
                        } catch (clipboardError) {
                            console.error('Clipboard read error:', clipboardError);
                            
                            // Fallback to text reading if file reading fails
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                const clipboardText = await navigator.clipboard.readText();
                                
                                try {
                                    const jsonData = JSON.parse(clipboardText);
                                    
                                    if (jsonData && (jsonData.faction || jsonData.abilities || jsonData.name)) {
                                        await processFileData(jsonData);
                                        return;
                                    } else {
                                        alert('No valid army list data found in clipboard. Please copy a valid JSON army list file or text.');
                                    }
                                } catch (jsonError) {
                                    console.error('Clipboard text fallback error:', jsonError);
                                    alert('No JSON file found in clipboard and clipboard text is not valid JSON. Please copy a valid JSON army list file.');
                                }
                            } else {
                                alert('Clipboard access not available in this browser.');
                            }
                        }
                    } else {
                        alert('Clipboard access not available in this browser.');
                    }
                } catch (clipboardError) {
                    console.error('Clipboard error:', clipboardError);
                    alert('Error accessing clipboard. Opening file explorer instead.');
                    // Fallback to file explorer
                    document.getElementById('file-input').click();
                }
            });

            // File input
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileUpload(file);
                    // Clear the file input so the same file can be selected again
                    e.target.value = '';
                }
            });

            // Add ability form
            document.getElementById('add-ability-form').addEventListener('submit', (e) => {
                e.preventDefault();
                addCustomAbility();
            });

            // Edit ability form
            document.getElementById('edit-ability-form').addEventListener('submit', (e) => {
                e.preventDefault();
                saveEditedAbility();
            });
        }

        // Dark mode functionality
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            AppState.isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', AppState.isDarkMode);
            
            const btn = document.getElementById('dark-mode-btn');
            btn.textContent = AppState.isDarkMode ? 'â˜€ï¸' : 'ðŸŒ™';
        }

        function loadDarkMode() {
            const savedMode = localStorage.getItem('darkMode');
            if (savedMode === 'true') {
                document.body.classList.add('dark-mode');
                AppState.isDarkMode = true;
                document.getElementById('dark-mode-btn').textContent = 'â˜€ï¸';
            }
        }

        // Process file data (for both file upload and clipboard import)
        async function processFileData(data) {
            try {
                console.log('Processing file data...');
                
                // Save current list if one exists
                if (AppState.currentList && AppState.currentListId) {
                    console.log('Saving current list before loading new one');
                    saveCurrentList();
                }
                
                console.log('Parsed JSON data:', data);
                const parsedList = parseNewRecruitJSON(data);
                console.log('Parsed list:', parsedList);
                console.log('Number of abilities found:', parsedList?.abilities?.length || 0);
                
                if (parsedList && parsedList.abilities && parsedList.abilities.length > 0) {
                    AppState.currentList = parsedList;
                    AppState.currentListId = parsedList.id; // Use the ID generated during parsing
                    
                    // Render the view first to create DOM elements
                    renderArmyView();
                    
                    // Save after rendering so DOM elements exist
                    saveCurrentList();
                    
                    console.log('Successfully loaded', parsedList.abilities.length, 'abilities');
                } else {
                    alert('No abilities found in the data. Please check the data format.');
                    console.error('No abilities found in parsed list:', parsedList);
                }
            } catch (error) {
                alert('Error processing data: ' + error.message);
                console.error('Data processing error:', error);
            }
        }

        // File upload and processing
        async function handleFileUpload(file) {
            try {
                console.log('Starting file upload for:', file.name);
                
                const text = await file.text();
                console.log('File text length:', text.length);
                const data = JSON.parse(text);
                
                // Use the shared processFileData function
                await processFileData(data);
                
            } catch (error) {
                alert('Error parsing file: ' + error.message);
                console.error('File upload error:', error);
            }
        }

        // Parse army list JSON data
        function parseNewRecruitJSON(data) {
            console.log('Starting JSON parsing...');
            const roster = data.roster || {};
            const forces = roster.forces || [];
            console.log('Found', forces.length, 'forces in roster');
            
            const list = {
                id: Date.now().toString(),
                name: roster.name || 'Unknown Army',
                points: roster.costs?.[0]?.value || 0,
                faction: '',
                detachment: '',
                abilities: [],
                notes: '',
                exclusions: 'Invulnerable Save\nLeader\nUnit Composition'
            };
            
            console.log('Initial list object:', list);

            for (const force of forces) {
                console.log('Processing force:', force.name || force.catalogueName);
                list.faction = force.catalogueName || '';
                list.faction = list.faction.replace('Imperium - ', '').replace('Chaos - ', '');
                
                walkSelections(force.selections || [], list);
            }

            console.log('After parsing, found', list.abilities.length, 'abilities');
            
            // Categorize abilities
            list.categorized = categorizeAbilities(list.abilities);
            console.log('Categorized abilities:', Object.keys(list.categorized).map(phase => `${phase}: ${list.categorized[phase].length}`));
            
            return list;
        }

        function walkSelections(selections, list, currentUnit = '') {
            for (const item of selections) {
                const name = item.name || '';
                const group = item.group || '';

                // Detect detachment
                if (name.toLowerCase().includes('detachment') || group.toLowerCase().includes('detachment')) {
                    for (const sub of item.selections || []) {
                        const detName = sub.name || '';
                        if (detName && detName.toLowerCase() !== 'detachment') {
                            list.detachment = detName;
                            break;
                        }
                    }

                    // Extract detachment abilities
                    for (const profile of item.profiles || []) {
                        if (profile.typeName === 'Abilities') {
                            const abilityName = profile.name || '';
                            let description = '';
                            for (const char of profile.characteristics || []) {
                                if (char.name === 'Description') {
                                    description = char.$text || '';
                                    break;
                                }
                            }
                            if (abilityName && description) {
                                list.abilities.push({
                                    id: generateId(),
                                    unitName: 'DETACHMENT',
                                    abilityName: abilityName,
                                    description: description,
                                    isDetachment: true,
                                    isStratagem: false,
                                    isEnemy: false,
                                    source: 'detachment'
                                });
                            }
                        }
                    }

                    // Extract detachment rules
                    for (const rule of item.rules || []) {
                        const abilityName = rule.name || '';
                        const description = rule.description || '';
                        if (abilityName && description) {
                            list.abilities.push({
                                id: generateId(),
                                unitName: 'DETACHMENT',
                                abilityName: abilityName,
                                description: description,
                                isDetachment: true,
                                isStratagem: false,
                                isEnemy: false,
                                source: 'detachment'
                            });
                        }
                    }
                }
                // Extract unit abilities
                else if (item.profiles) {
                    for (const profile of item.profiles) {
                        if (profile.typeName === 'Abilities') {
                            const abilityName = profile.name || '';
                            let description = '';
                            for (const char of profile.characteristics || []) {
                                if (char.name === 'Description') {
                                    description = char.$text || '';
                                    break;
                                }
                            }
                            if (abilityName && description) {
                                list.abilities.push({
                                    id: generateId(),
                                    unitName: currentUnit || name,
                                    abilityName: abilityName,
                                    description: description,
                                    isDetachment: false,
                                    isStratagem: false,
                                    isEnemy: checkIfEnemy(description),
                                    source: 'unit'
                                });
                            }
                        }
                    }
                }

                // Recurse
                if (item.selections) {
                    walkSelections(item.selections, list, currentUnit || name);
                }
            }
        }

        function checkIfEnemy(description) {
            const desc = description.toLowerCase().replace(/[Â´']/g, '');
            const enemyKeywords = [
                'each time an enemy unit',
                'each time an enemy model',
                'in your opponents',
                'at the end of your opponent',
                'at the start of your opponent',
                'during your opponent',
                'model is destroyed',
                'after an enemy unit has',
                'when an enemy',
                'if an enemy',
                'in your opponents command',
                'in your opponents movement',
                'in your opponents shooting',
                'in your opponents charge',
                'in your opponents fight',
            ];
            return enemyKeywords.some(kw => desc.includes(kw));
        }

        // Sort abilities by game phase
        function categorizeAbilities(abilities) {
            console.log('Categorizing', abilities.length, 'abilities');
            
            const phases = {
                'DEPLOYMENT / RESERVES': [],
                'COMMAND PHASE': [],
                'MOVEMENT PHASE': [],
                'SHOOTING PHASE': [],
                'CHARGE PHASE': [],
                'FIGHT PHASE': [],
                'ANY PHASE': [],
                'OTHER': []
            };

            const phaseKeywords = {
                'FIGHT PHASE': {
                    include: ['when: fight phase', ' fight', ' fights', ' fight phase', ' weapon skill', ' melee attack', ' melee weapon'],
                    exclude: ['fire overwatch']
                },
                'CHARGE PHASE': {
                    include: ['when: charge phase', ' charge phase', ' charge roll', ' charge move'],
                    exclude: []
                },
                'SHOOTING PHASE': {
                    include: ['when: shooting phase', ' shoot', ' shooting phase', ' ranged attack', ' ranged weapon', 'stealth'],
                    exclude: ['fire overwatch']
                },
                'MOVEMENT PHASE': {
                    include: ['when: movement phase', ' moves', ' a move', 'normal move', ' fallback', ' fall back', ' advance ', ' movement phase', ' deep strike'],
                    exclude: ['as if it were your movement phase']
                },
                'COMMAND PHASE': {
                    include: ['when: command phase', ' start of your turn', ' command phase', ' order', ' battle-shock'],
                    exclude: []
                },
                'ANY PHASE': {
                    include: ['when: any phase', ' any phase', 'each time', ' attack', ' weapon', ' stratagem'],
                    exclude: []
                },
                'DEPLOYMENT / RESERVES': {
                    include: [' reserves', ' declare battle formations', ' scouts', ' infiltrators'],
                    exclude: []
                }
            };

            for (const ability of abilities) {
                let desc = ability.description.toLowerCase().replace(/[Â´']/g, '');
                
                // Remove stratagem prefixes to avoid false keyword matches
                desc = desc.replace(/^when:\s*/i, '');
                desc = desc.replace(/^target:\s*/i, '');
                desc = desc.replace(/^effect:\s*/i, '');
                
                console.log(`Processing ability: ${ability.abilityName} - Description: ${desc.substring(0, 100)}...`);
                let found = false;

                for (const [phase, keywords] of Object.entries(phaseKeywords)) {
                    if (found && phase === 'ANY PHASE') break;

                    const hasInclude = keywords.include.some(kw => desc.includes(kw));
                    const hasExclude = keywords.exclude.some(kw => desc.includes(kw));

                    console.log(`  Phase ${phase}: include=${hasInclude}, exclude=${hasExclude}`);

                    if (hasInclude && !hasExclude) {
                        phases[phase].push(ability);
                        console.log(`  -> Assigned to ${phase}`);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    phases['OTHER'].push(ability);
                    console.log(`  -> Assigned to OTHER`);
                }
            }

            console.log('Final categorization:', Object.keys(phases).map(phase => `${phase}: ${phases[phase].length}`));
            return phases;
        }

        // Smooth scrolling for navigation
        function setupSmoothScroll() {
            // Calculate the sticky bar height (approx 48px for action bar + 8px padding)
            const stickyOffset = 56;
            
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    
                    if (targetElement) {
                        const targetPosition = targetElement.offsetTop - stickyOffset;
                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });
        }

        // Render the main army view
        function renderArmyView() {
            console.log('Rendering army view...');
            const armyView = document.getElementById('army-view');
            const welcomeScreen = document.getElementById('welcome-screen');

            welcomeScreen.style.display = 'none';
            armyView.style.display = 'block';

            const list = AppState.currentList;
            console.log('Current list:', list);
            console.log('Number of abilities in list:', list?.abilities?.length || 0);
            console.log('Categorized phases:', list?.categorized ? Object.keys(list.categorized) : 'none');

            armyView.innerHTML = `
                <div class="action-bar">
                    <div class="action-bar-row">
                        <button class="action-btn" onclick="showUploadScreen()" title="Return to Overview">HOME</button>
                        <button class="action-btn" onclick="deleteCurrentList()" title="Delete List">DELETE</button>
                        <button class="action-btn" onclick="renameCurrentList()" title="Rename List">RENAME</button>
                        <button class="action-btn" onclick="saveCurrentList()" title="Save List">SAVE</button>
                        <button class="action-btn" onclick="showAddAbilityModal()" title="Add Custom Entry">CUSTOM</button>
                        <button class="action-btn" onclick="fetchAndAddCoreStratagems()" title="Fetch core stratagems">CORE</button>
                        <button class="action-btn" onclick="fetchAndAddFactionStratagems()" title="Fetch faction stratagems">DETACHM.</button>
                    </div>
                    <div class="action-bar-row">
                        <a href="#phase-deployment" class="action-btn" title="Deployment / Reserves">DEPLOY</a>
                        <a href="#phase-command" class="action-btn" title="Command Phase">COMMAND</a>
                        <a href="#phase-movement" class="action-btn" title="Movement Phase">MOVE</a>
                        <a href="#phase-shooting" class="action-btn" title="Shooting Phase">SHOOT</a>
                        <a href="#phase-charge" class="action-btn" title="Charge Phase">CHARGE</a>
                        <a href="#phase-fight" class="action-btn" title="Fight Phase">FIGHT</a>
                        <a href="#phase-any" class="action-btn" title="Any Phase">ANY</a>
                        <a href="#phase-other" class="action-btn" title="Any Phase">OTHER</a>
                    </div>
                </div>

                <div class="army-header">
                    <h2>${list.name}</h2>
                    <div class="army-meta">
                        <span><strong>Faction:</strong> ${list.faction}</span>
                        <span><strong>Detachment:</strong> ${list.detachment || 'None'}</span>
                        <span><strong>Points:</strong> ${list.points}</span>
                    </div>
                </div>

                <div class="notes-panel">
                    <div class="notes-container">
                        <textarea class="notes-textarea" id="notes-area" placeholder="Take notes...">${list.notes || ''}</textarea>
                        <textarea class="exclusion-textarea" id="exclusion-area" placeholder="Exclude abilities (one per line)...">${list.exclusions || ''}</textarea>
                    </div>
                </div>

                <div class="controls-bar">
                    <input type="text" class="search-box" id="search-box" placeholder="Search abilities / unit names...">
                    <div class="filter-buttons">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="detachment">Detachment</button>
                        <button class="filter-btn" data-filter="stratagem">Stratagems</button>
                        <button class="filter-btn" data-filter="enemy">Reactions</button>
                    </div>
                </div>

                <div id="abilities-container">
                    ${renderPhases(list.categorized)}
                </div>
            `;

            setupArmyViewListeners();
            setupSmoothScroll();
            
            // Sync exclusion textarea content to app state and apply filter immediately
            const exclusionArea = document.getElementById('exclusion-area');
            if (exclusionArea && exclusionArea.value.trim()) {
                AppState.currentList.exclusions = exclusionArea.value;
                applyExclusionFilter();
            }
            
            // Reset filter to "All" and clear search after DOM is ready
            setTimeout(() => {
                const allFilterBtn = document.querySelector('.filter-btn[data-filter="all"]');
                if (allFilterBtn) {
                    allFilterBtn.classList.add('active');
                }
                
                const searchBox = document.getElementById('search-box');
                if (searchBox) {
                    searchBox.value = '';
                }
                
                // Apply the reset filters to show all abilities
                document.querySelectorAll('.ability').forEach(ability => {
                    ability.style.display = 'block';
                });
            }, 100);
        }

        function renderPhases(categorized) {
            console.log('Rendering phases with categorized data:', categorized);
            console.log('Available phases:', Object.keys(categorized || {}));
            let html = '';
            
            const phaseIds = {
                'DEPLOYMENT / RESERVES': 'phase-deployment',
                'COMMAND PHASE': 'phase-command',
                'MOVEMENT PHASE': 'phase-movement',
                'SHOOTING PHASE': 'phase-shooting',
                'CHARGE PHASE': 'phase-charge',
                'FIGHT PHASE': 'phase-fight',
                'ANY PHASE': 'phase-any',
                'OTHER': 'phase-other'
            };

            // Ensure all phases exist even if empty
            const allPhases = ['DEPLOYMENT / RESERVES', 'COMMAND PHASE', 'MOVEMENT PHASE', 'SHOOTING PHASE', 'CHARGE PHASE', 'FIGHT PHASE', 'ANY PHASE', 'OTHER'];
            
            for (const phase of allPhases) {
                const abilities = categorized[phase] || [];
                console.log(`Phase ${phase} has ${abilities.length} abilities`);
                
                if (abilities.length > 0) {
                    console.log(`  Abilities in ${phase}:`, abilities.map(a => a.abilityName));
                }
                
                const phaseId = phaseIds[phase] || 'phase-other';
                
                const abilitiesHTML = abilities.map(ability => renderAbility(ability)).join('');
                console.log(`Generated abilities HTML for ${phase}:`, abilitiesHTML.substring(0, 200) + '...');
                
                html += `
                    <div class="phase-section" data-phase="${phase}" id="${phaseId}">
                        <h3>${phase}</h3>
                        ${abilitiesHTML}
                    </div>
                `;
            }
            
            console.log('Generated HTML length:', html.length);
            return html;
        }

        function renderAbility(ability) {
            console.log('Rendering ability:', ability.abilityName, 'for unit:', ability.unitName);
            
            const classes = ['ability'];
            if (ability.isEnemy) classes.push('enemy');
            if (ability.isStratagem) classes.push('stratagem');
            if (ability.isDetachment) classes.push('detachment');

            const description = formatDescription(ability.description);
            
            // Extract keywords (boldened words)
            const keywords = extractKeywords(ability.description);
            const keywordsHTML = keywords.length > 0 
                ? `<div class="ability-keywords">Keywords: ${keywords.join(', ')}</div>`
                : '';

            const html = `
                <div class="${classes.join(' ')}" data-ability-id="${ability.id}" draggable="true">
                    <div class="ability-controls">
                        <button class="color-btn" onclick="toggleEnemyColor('${ability.id}')" title="Toggle color">ðŸŽ¨</button>
                        <button class="duplicate-btn" onclick="duplicateAbility('${ability.id}')" title="Duplicate">ðŸ“‘</button>
                        <button class="edit-btn" onclick="editAbility('${ability.id}')" title="Edit">âœï¸</button>
                        <button class="delete-btn" onclick="deleteAbility('${ability.id}')" title="Delete">âœ•</button>
                    </div>
                    <div class="unit-name">${ability.unitName}</div>
                    <div class="ability-name">${ability.abilityName}</div>
                    <div class="ability-desc">${description}</div>
                    ${keywordsHTML}
                </div>
            `;
            
            console.log('Generated HTML for ability:', html.substring(0, 200) + '...');
            return html;
        }
        
        function extractKeywords(text) {
            // Extract all words that would be bolded (all-caps words of 2+ letters)
            const matches = text.match(/\b[A-Z]{2,}\b/g);
            if (!matches) return [];
            
            // Filter out stratagem formatting prefixes and common non-keywords
            const excludeWords = ['WHEN', 'TARGET', 'EFFECT', 'RESTRICTIONS', 'CP', 'PHASE'];
            const filtered = matches.filter(word => !excludeWords.includes(word));
            
            // Remove duplicates and sort
            const unique = [...new Set(filtered)];
            return unique.sort();
        }

        function formatDescription(text) {
            // Remove all ^^ characters
            text = text.replace(/\^\^/g, '');
            // Handle regular **text** pattern
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Bold all-caps keywords
            text = text.replace(/\b([A-Z]{2,})\b/g, '<strong>$1</strong>');
            return text;
        }

        function setupArmyViewListeners() {
            // Search
            document.getElementById('search-box').addEventListener('input', handleSearch);

            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', handleFilter);
            });

            // Notes
            let notesTimeout;
            document.getElementById('notes-area').addEventListener('input', (e) => {
                AppState.currentList.notes = e.target.value;
                
                // Debounce auto-save
                clearTimeout(notesTimeout);
                notesTimeout = setTimeout(() => {
                    saveCurrentList();
                }, 1000);
            });

            // Exclusion filter
            let exclusionTimeout;
            document.getElementById('exclusion-area').addEventListener('input', (e) => {
                AppState.currentList.exclusions = e.target.value;
                
                // Apply exclusion filter immediately
                applyExclusionFilter();
                
                // Debounce auto-save
                clearTimeout(exclusionTimeout);
                exclusionTimeout = setTimeout(() => {
                    saveCurrentList();
                }, 1000);
            });

            // Drag and drop
            setupDragAndDrop();
        }

        // Filter out excluded abilities
        function applyExclusionFilter() {
            const exclusionText = AppState.currentList.exclusions || '';
            const exclusionTerms = exclusionText.split('\n')
                .map(term => term.trim().toLowerCase())
                .filter(term => term.length > 0);
            
            document.querySelectorAll('.ability').forEach(ability => {
                const abilityName = ability.querySelector('.ability-name')?.textContent.toLowerCase() || '';
                const unitName = ability.querySelector('.unit-name')?.textContent.toLowerCase() || '';
                const fullText = `${unitName} ${abilityName}`;
                
                const isExcluded = exclusionTerms.some(term => 
                    abilityName.includes(term) || 
                    unitName.includes(term) || 
                    fullText.includes(term)
                );
                
                // Store exclusion state
                ability.dataset.excluded = isExcluded;
                
                // Apply current search and filter states
                applyCurrentFilters(ability);
            });
        }

        function applyCurrentFilters(ability) {
            const searchBox = document.getElementById('search-box');
            const activeFilter = document.querySelector('.filter-btn.active');
            const searchQuery = searchBox ? searchBox.value.toLowerCase() : '';
            const filterValue = activeFilter ? activeFilter.dataset.filter : 'all';
            
            // Check if excluded
            if (ability.dataset.excluded === 'true') {
                ability.style.display = 'none';
                return;
            }
            
            // Check search
            if (searchQuery && !ability.textContent.toLowerCase().includes(searchQuery)) {
                ability.style.display = 'none';
                return;
            }
            
            // Check filter
            if (filterValue !== 'all' && !ability.classList.contains(filterValue)) {
                ability.style.display = 'none';
                return;
            }
            
            ability.style.display = 'block';
        }

        // Search and filter abilities
        function handleSearch(e) {
            document.querySelectorAll('.ability').forEach(ability => {
                applyCurrentFilters(ability);
            });
        }

        function handleFilter(e) {
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');

            document.querySelectorAll('.ability').forEach(ability => {
                applyCurrentFilters(ability);
            });
        }

        // Drag and drop functionality
        function setupDragAndDrop() {
            document.querySelectorAll('.ability').forEach(ability => {
                ability.addEventListener('dragstart', handleDragStart);
                ability.addEventListener('dragend', handleDragEnd);
            });

            document.querySelectorAll('.phase-section').forEach(section => {
                section.addEventListener('dragover', handleDragOver);
                section.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            AppState.draggedElement = e.target;
            e.target.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Rebuild the abilities list based on current DOM order
            const newAbilitiesList = [];
            document.querySelectorAll('.phase-section').forEach(section => {
                section.querySelectorAll('.ability').forEach(abilityElement => {
                    const abilityId = abilityElement.dataset.abilityId;
                    const ability = findAbilityById(abilityId);
                    if (ability) {
                        newAbilitiesList.push(ability);
                    }
                });
            });
            
            // Update the abilities list with the new order
            AppState.currentList.abilities = newAbilitiesList;
            
            // Re-categorize based on current positions
            AppState.currentList.categorized = categorizeAbilities(AppState.currentList.abilities);
            
            saveCurrentList();
        }

        function handleDragOver(e) {
            e.preventDefault();
            const afterElement = getDragAfterElement(e.currentTarget, e.clientY);
            const section = e.currentTarget;

            if (afterElement == null) {
                section.appendChild(AppState.draggedElement);
            } else {
                section.insertBefore(AppState.draggedElement, afterElement);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.ability:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Ability editing and actions
        function toggleEnemyColor(abilityId) {
            const element = document.querySelector(`[data-ability-id="${abilityId}"]`);
            element.classList.toggle('enemy');
            
            const ability = findAbilityById(abilityId);
            if (ability) {
                ability.isEnemy = element.classList.contains('enemy');
                saveCurrentList();
            }
        }

        function duplicateAbility(abilityId) {
            const ability = findAbilityById(abilityId);
            if (!ability) return;

            const newAbility = { ...ability, id: generateId() };
            
            // Find the phase of the original ability
            const phaseSections = document.querySelectorAll('.phase-section');
            let originalPhase = null;
            let originalElement = null;
            
            for (const section of phaseSections) {
                const element = section.querySelector(`[data-ability-id="${abilityId}"]`);
                if (element) {
                    originalPhase = section;
                    originalElement = element;
                    break;
                }
            }
            
            if (!originalPhase || !originalElement) return;
            
            // Insert the duplicate after the original in the DOM
            const duplicateHTML = renderAbility(newAbility);
            originalElement.insertAdjacentHTML('afterend', duplicateHTML);
            
            // Add to abilities array after the original
            const originalIndex = AppState.currentList.abilities.findIndex(a => a.id === abilityId);
            AppState.currentList.abilities.splice(originalIndex + 1, 0, newAbility);
            
            // Re-setup drag and drop for the new element
            const newElement = originalPhase.querySelector(`[data-ability-id="${newAbility.id}"]`);
            if (newElement) {
                newElement.addEventListener('dragstart', handleDragStart);
                newElement.addEventListener('dragend', handleDragEnd);
            }
            
            saveCurrentList();
        }

        function editAbility(abilityId) {
            const ability = findAbilityById(abilityId);
            if (!ability) return;

            document.getElementById('edit-ability-id').value = abilityId;
            document.getElementById('edit-ability-unit').value = ability.unitName;
            document.getElementById('edit-ability-name').value = ability.abilityName;
            document.getElementById('edit-ability-desc').value = ability.description;

            openModal('edit-ability-modal');
        }

        function saveEditedAbility() {
            const abilityId = document.getElementById('edit-ability-id').value;
            const ability = findAbilityById(abilityId);
            
            if (ability) {
                // Store current search and filter state
                const searchBox = document.getElementById('search-box');
                const searchValue = searchBox ? searchBox.value : '';
                const activeFilter = document.querySelector('.filter-btn.active');
                const filterValue = activeFilter ? activeFilter.dataset.filter : 'all';
                
                // Store current scroll position
                const scrollPosition = window.pageYOffset;
                
                // Update ability data
                ability.unitName = document.getElementById('edit-ability-unit').value;
                ability.abilityName = document.getElementById('edit-ability-name').value;
                ability.description = document.getElementById('edit-ability-desc').value;
                
                // Check if enemy-triggered status changed based on new description
                ability.isEnemy = checkIfEnemy(ability.description);
                
                // Update only the specific ability element in the DOM
                const abilityElement = document.querySelector(`[data-ability-id="${abilityId}"]`);
                if (abilityElement) {
                    // Update classes
                    abilityElement.classList.toggle('enemy', ability.isEnemy);
                    abilityElement.classList.toggle('stratagem', ability.isStratagem);
                    abilityElement.classList.toggle('detachment', ability.isDetachment);
                    
                    // Update content
                    const description = formatDescription(ability.description);
                    const keywords = extractKeywords(ability.description);
                    const keywordsHTML = keywords.length > 0 
                        ? `<div class="ability-keywords">Keywords: ${keywords.join(', ')}</div>`
                        : '';
                    
                    abilityElement.innerHTML = `
                        <div class="ability-controls">
                            <button class="color-btn" onclick="toggleEnemyColor('${ability.id}')" title="Toggle color">ðŸŽ¨</button>
                            <button class="duplicate-btn" onclick="duplicateAbility('${ability.id}')" title="Duplicate">ðŸ“‘</button>
                            <button class="edit-btn" onclick="editAbility('${ability.id}')" title="Edit">âœï¸</button>
                            <button class="delete-btn" onclick="deleteAbility('${ability.id}')" title="Delete">âœ•</button>
                        </div>
                        <div class="unit-name">${ability.unitName}</div>
                        <div class="ability-name">${ability.abilityName}</div>
                        <div class="ability-desc">${description}</div>
                        ${keywordsHTML}
                    `;
                    
                    // Re-attach event listeners for the new buttons
                    const newButtons = abilityElement.querySelectorAll('.ability-controls button');
                    newButtons.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                    });
                }
                
                // Restore search and filter state
                if (searchBox) {
                    searchBox.value = searchValue;
                    if (searchValue) {
                        handleSearch({ target: searchBox });
                    }
                }
                
                if (activeFilter && filterValue !== 'all') {
                    handleFilter({ target: activeFilter });
                }
                
                // Restore scroll position
                window.scrollTo(0, scrollPosition);
                
                saveCurrentList();
            }

            closeModal('edit-ability-modal');
        }

        function deleteAbility(abilityId) {
            const element = document.querySelector(`[data-ability-id="${abilityId}"]`);
            element.remove();

            const index = AppState.currentList.abilities.findIndex(a => a.id === abilityId);
            if (index !== -1) {
                AppState.currentList.abilities.splice(index, 1);
                saveCurrentList();
            }
        }

        function addCustomAbility() {
            const phase = document.getElementById('ability-phase').value;
            const unit = document.getElementById('ability-unit').value.trim();
            const name = document.getElementById('ability-name').value.trim();
            const desc = document.getElementById('ability-desc').value.trim();

            if (!unit || !name || !desc) {
                alert('Please fill in all fields');
                return;
            }

            const ability = {
                id: generateId(),
                unitName: unit,
                abilityName: name,
                description: desc,
                isDetachment: false,
                isStratagem: false,
                isEnemy: checkIfEnemy(desc),
                source: 'custom'
            };

            // Add to the main abilities list
            AppState.currentList.abilities.push(ability);
            
            // Add directly to the selected phase at the top (unshift adds to beginning)
            if (!AppState.currentList.categorized[phase]) {
                AppState.currentList.categorized[phase] = [];
            }
            AppState.currentList.categorized[phase].unshift(ability);
            
            // Re-render to show the new ability at the top of the selected phase
            renderArmyView();

            // Clear form
            document.getElementById('ability-unit').value = '';
            document.getElementById('ability-name').value = '';
            document.getElementById('ability-desc').value = '';

            saveCurrentList();
            closeModal('add-ability-modal');
        }

        // Save and load army lists
        function saveCurrentList() {
            if (!AppState.currentList) {
                alert('No list to save');
                return;
            }

            // Update categorized data to reflect current DOM states
            const updatedCategorized = {};
            document.querySelectorAll('.phase-section').forEach(section => {
                const phaseName = section.dataset.phase;
                const abilities = [];
                
                section.querySelectorAll('.ability').forEach(abilityElement => {
                    const abilityId = abilityElement.dataset.abilityId;
                    const ability = AppState.currentList.abilities.find(a => a.id === abilityId);
                    if (ability) {
                        // Update enemy status from DOM
                        ability.isEnemy = abilityElement.classList.contains('enemy');
                        abilities.push(ability);
                    }
                });
                
                updatedCategorized[phaseName] = abilities;
            });
            
            AppState.currentList.categorized = updatedCategorized;

            const savedLists = getSavedLists();
            savedLists[AppState.currentListId] = {
                ...AppState.currentList,
                lastModified: new Date().toISOString()
            };
            localStorage.setItem('savedLists', JSON.stringify(savedLists));
            
            // Show brief confirmation
            const btn = document.getElementById('menu-save');
            if (btn) {
                const originalText = btn.innerHTML;
                btn.innerHTML = 'âœ… Saved!';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 1500);
            }
        }

        let currentSortMethod = 'name'; // Default sort by name

        function sortLists(sortMethod) {
            currentSortMethod = sortMethod;
            
            // Update button states
            document.querySelectorAll('.sort-controls .filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-sort="${sortMethod}"]`).classList.add('active');
            
            loadSavedLists();
        }

        function getSavedLists() {
            const saved = localStorage.getItem('savedLists');
            return saved ? JSON.parse(saved) : {};
        }

        function loadSavedLists() {
            const savedLists = getSavedLists();
            const container = document.getElementById('saved-lists-container');

            if (Object.keys(savedLists).length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-light-secondary);">
                        <p>No saved lists yet. Upload an army list to get started!</p>
                    </div>
                `;
                return;
            }

            // Convert to array and sort
            let listsArray = Object.entries(savedLists);
            
            switch (currentSortMethod) {
                case 'name':
                    listsArray.sort((a, b) => {
                        // Natural sorting that handles numbers properly
                        const nameA = a[1].name;
                        const nameB = b[1].name;
                        
                        // Extract numbers from the beginning for proper numerical sorting
                        const numA = parseInt(nameA.match(/^\d+/)?.[0] || '0');
                        const numB = parseInt(nameB.match(/^\d+/)?.[0] || '0');
                        
                        // If both start with numbers, sort numerically first
                        if (numA > 0 && numB > 0) {
                            if (numA !== numB) {
                                return numA - numB;
                            }
                            // If numbers are equal, sort alphabetically
                            return nameA.localeCompare(nameB);
                        }
                        
                        // If only one starts with a number, the numbered one comes first
                        if (numA > 0) return -1;
                        if (numB > 0) return 1;
                        
                        // Otherwise, sort alphabetically
                        return nameA.localeCompare(nameB);
                    });
                    break;
                case 'faction':
                    listsArray.sort((a, b) => {
                        const factionA = a[1].faction || '';
                        const factionB = b[1].faction || '';
                        const detachmentA = a[1].detachment || '';
                        const detachmentB = b[1].detachment || '';
                        
                        // Sort by faction first
                        const factionCompare = factionA.localeCompare(factionB);
                        if (factionCompare !== 0) {
                            return factionCompare;
                        }
                        
                        // If factions are equal, sort by detachment
                        return detachmentA.localeCompare(detachmentB);
                    });
                    break;
                case 'date':
                    listsArray.sort((a, b) => new Date(b[1].lastModified) - new Date(a[1].lastModified));
                    break;
                case 'points':
                    listsArray.sort((a, b) => {
                        const pointsA = parseInt(a[1].points) || 0;
                        const pointsB = parseInt(b[1].points) || 0;
                        if (pointsA !== pointsB) {
                            return pointsA - pointsB; // Lower points first
                        }
                        // If points are equal, sort by name
                        return a[1].name.localeCompare(b[1].name);
                    });
                    break;
            }

            container.innerHTML = `
                ${listsArray.map(([id, list]) => `
                    <div class="list-card" onclick="loadList('${id}')">
                        <div class="list-info">
                            <h4>${list.name}</h4>
                            <p>${list.faction}${list.detachment ? ' â€¢ ' + list.detachment : ''} â€¢ ${list.points}pts â€¢ ${new Date(list.lastModified).toLocaleDateString()} - ${new Date(list.lastModified).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', hour12: false })}</p>
                        </div>
                        <div class="list-actions">
                            <button class="btn btn-sm btn-primary" onclick="event.stopPropagation(); loadList('${id}')">
                                Open
                            </button>
                            <button class="btn btn-sm btn-primary" onclick="event.stopPropagation(); editSavedListName('${id}')">
                                Edit
                            </button>
                            <button class="btn btn-sm" style="background: var(--danger); color: white;" onclick="event.stopPropagation(); deleteSavedList('${id}')">
                                Delete
                            </button>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function loadList(listId) {
            const savedLists = getSavedLists();
            const list = savedLists[listId];
            
            if (list) {
                // Deep clone to avoid reference issues
                AppState.currentList = JSON.parse(JSON.stringify(list));
                AppState.currentListId = listId;
                
                // Only recategorize if no categorized data exists (for backward compatibility)
                if (!AppState.currentList.categorized) {
                    AppState.currentList.categorized = categorizeAbilities(AppState.currentList.abilities);
                }
                
                renderArmyView();
            }
        }

        function editSavedListName(listId) {
            const savedLists = getSavedLists();
            const list = savedLists[listId];
            
            if (list) {
                const newName = prompt('Enter new name for the list:', list.name);
                if (newName && newName.trim()) {
                    list.name = newName.trim();
                    list.lastModified = new Date().toISOString();
                    localStorage.setItem('savedLists', JSON.stringify(savedLists));
                    loadSavedLists();
                    
                    // If this is the currently active list, update it too
                    if (AppState.currentListId === listId) {
                        AppState.currentList.name = newName.trim();
                        renderArmyView();
                    }
                }
            }
        }

        function deleteSavedList(listId, skipConfirmation = false) {
            if (!skipConfirmation && !confirm('Delete this saved list?')) return;

            const savedLists = getSavedLists();
            delete savedLists[listId];
            localStorage.setItem('savedLists', JSON.stringify(savedLists));
            
            // If we're on the welcome screen, refresh the list
            if (document.getElementById('welcome-screen').style.display !== 'none') {
                loadSavedLists();
            }
        }

        function renameCurrentList() {
            if (!AppState.currentList) {
                alert('No list is currently active');
                return;
            }
            
            const newName = prompt('Enter new name for the list:', AppState.currentList.name);
            if (newName && newName.trim()) {
                AppState.currentList.name = newName.trim();
                saveCurrentList();
                renderArmyView();
            }
        }

        function deleteCurrentList() {
            if (!AppState.currentListId) {
                alert('No list is currently active');
                return;
            }
            
            if (!confirm('Delete current list? This cannot be undone.')) return;

            deleteSavedList(AppState.currentListId, true); // Skip confirmation since we already asked
            showUploadScreen();
        }

        // Handle notes and exclusions
        function parseNotesAndExclusions(content) {
            const separator = '---';
            const parts = content.split(separator);
            
            if (parts.length === 1) {
                // No separator found, treat everything as notes
                return {
                    notes: parts[0].trim(),
                    exclusions: ''
                };
            } else {
                // Separator found, split into notes and exclusions
                return {
                    notes: parts[0].trim(),
                    exclusions: parts.slice(1).join(separator).trim()
                };
            }
        }

        function formatNotesAndExclusions(notes, exclusions) {
            if (!exclusions.trim()) {
                return notes || '';
            }
            
            const exclusionText = exclusions.trim();
            const notesText = notes || '';
            
            if (!notesText.trim()) {
                return `---\nExclude abilities (one per line):\n${exclusionText}`;
            }
            
            return `${notesText}\n\n---\nExclude abilities (one per line):\n${exclusionText}`;
        }

        // UI state management
        function updateAppVersion() {
            const versionElement = document.getElementById('app-version');
            if (versionElement) {
                versionElement.textContent = `v${AppState.appVersion}`;
            }
        }

        // Navigation functions
        
        function showUploadScreen() {
            document.getElementById('welcome-screen').style.display = 'block';
            document.getElementById('army-view').style.display = 'none';
            AppState.currentList = null;
            AppState.currentListId = null;
            loadSavedLists(); // Refresh the saved lists display
        }

        function showSavedLists() {
            showUploadScreen();
        }

        function showAddAbilityModal() {
            if (!AppState.currentList) {
                alert('Please load an army list first');
                return;
            }
            openModal('add-ability-modal');
        }
        
        function showStratagemModal() {
            if (!AppState.currentList) {
                alert('Please load an army list first');
                return;
            }
            openModal('stratagem-modal');
        }
        
        // Handle stratagem form submission
        document.addEventListener('DOMContentLoaded', () => {
            const stratagemForm = document.getElementById('stratagem-form');
            if (stratagemForm) {
                stratagemForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await fetchStratagems();
                });
            }
        });
        
        async function fetchStratagems() {
            const url = document.getElementById('stratagem-url').value;
            const includeCore = document.getElementById('include-core-stratagems').checked;
            const statusDiv = document.getElementById('stratagem-status');
            
            statusDiv.innerHTML = 'â³ Fetching stratagems...';
            statusDiv.style.color = 'var(--info)';
            
            try {
                // Note: Actual fetch would require CORS proxy or backend
                // This is a placeholder for the structure
                alert('Note: Feature currently not implemented.');
                
                statusDiv.innerHTML = 'âš ï¸ Manual entry required (see alert)';
                statusDiv.style.color = 'var(--warning)';
                
                // Placeholder for actual implementation:
                /*
                const detachmentName = AppState.currentList.detachment;
                const response = await fetch(proxyUrl + url);
                const html = await response.text();
                // Parse stratagems from HTML
                // Add to AppState.currentList.abilities
                // Re-categorize and render
                */
                
            } catch (error) {
                statusDiv.innerHTML = 'âŒ Error fetching stratagems';
                statusDiv.style.color = 'var(--danger)';
                console.error(error);
            }
        }

        // Modal helpers
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // Close modal on background click
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });

        // Utility functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function findAbilityById(id) {
            return AppState.currentList?.abilities.find(a => a.id === id);
        }

        // ========================================
        // STRATAGEM FETCHER FUNCTIONALITY
        // ========================================
        
        const GITHUB_BASE_URL = 'https://raw.githubusercontent.com/game-datacards/datasources/main/10th/gdc/';
        const FACTION_FILES = {
            'grey knights': 'greyknights.json',
            'space marines': 'space_marines.json',
            'necrons': 'necrons.json',
            'tyranids': 'tyranids.json',
            'orks': 'orks.json',
            'aeldari': 'aeldari.json',
            "t'au empire": 'tau.json',
            "tau empire": 'tau.json',
            'chaos space marines': 'chaos_spacemarines.json',
            'chaos daemons': 'chaosdaemons.json',
            'astra militarum': 'astramilitarum.json',
            'adeptus custodes': 'adeptuscustodes.json',
            'adepta sororitas': 'adeptasororitas.json',
            'adeptus mechanicus': 'adeptusmechanicus.json',
            'death guard': 'deathguard.json',
            'thousand sons': 'thousandsons.json',
            'world eaters': 'worldeaters.json',
            'drukhari': 'drukhari.json',
            'genestealer cults': 'gsc.json',
            'imperial knights': 'imperialknights.json',
            'leagues of votann': 'votann.json'
        };


        async function getCoreStratagems() {
            try {
                const url = GITHUB_BASE_URL + 'core.json';
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const coreData = await response.json();
                const stratagems = [];
                
                // Extract stratagems from the core data
                if (coreData.stratagems && Array.isArray(coreData.stratagems)) {
                    coreData.stratagems.forEach(item => {
                        // Format phase array to readable text
                        let phaseText = 'Any Phase';
                        if (item.phase && Array.isArray(item.phase)) {
                            const phaseMap = {
                                'movement': 'Movement Phase',
                                'shooting': 'Shooting Phase', 
                                'fight': 'Fight Phase',
                                'charge': 'Charge Phase',
                                'command': 'Command Phase',
                                'any': 'Any Phase'
                            };
                            phaseText = item.phase.map(p => phaseMap[p] || p.charAt(0).toUpperCase() + p.slice(1) + ' Phase').join(', ');
                        } else if (item.when) {
                            phaseText = item.when;
                        }
                        
                        // Build formatted description
                        let formattedDesc = '';
                        if (item.target) {
                            formattedDesc += `TARGET: ${item.target}\n\n`;
                        }
                        formattedDesc += `EFFECT: ${item.effect}` || `EFFECT: ${item.description}` || '';
                        if (item.restrictions && item.restrictions.trim()) {
                            formattedDesc += `\n\nRESTRICTIONS: ${item.restrictions}`;
                        }
                        
                        stratagems.push({
                            name: item.name || 'Unknown Stratagem',
                            cp: item.cost ? `${item.cost}CP` : '?CP',
                            when: phaseText,
                            description: formattedDesc,
                            source: 'Core'
                        });
                    });
                }
                
                return stratagems;
            } catch (error) {
                console.error('Error fetching core stratagems:', error);
                // Fallback to empty array if fetch fails
                return [];
            }
        }

        async function fetchAndAddCoreStratagems() {
            if (!AppState.currentList) {
                alert('Please load an army list first');
                return;
            }
            
            try {
                const coreStratagems = await getCoreStratagems();
                
                if (coreStratagems.length === 0) {
                    throw new Error('No core stratagems found');
                }
                
                let addedCount = 0;
                coreStratagems.forEach(strat => {
                    const ability = {
                        id: generateId(),
                        unitName: `STRATAGEM (${strat.source})`,
                        abilityName: `${strat.name} [${strat.cp}]`,
                        description: `WHEN: ${strat.when}\n\n${strat.description}`,
                        isDetachment: false,
                        isStratagem: true,
                        isEnemy: checkIfEnemy(strat.description),
                        source: 'stratagem'
                    };
                    
                    AppState.currentList.abilities.push(ability);
                    addedCount++;
                });
                
                AppState.currentList.categorized = categorizeAbilities(AppState.currentList.abilities);
                renderArmyView();
                saveCurrentList();
                
                alert(`Successfully added ${addedCount} core stratagems!`);
                
            } catch (error) {
                console.error('Error fetching core stratagems:', error);
                alert(`Error fetching core stratagems: ${error.message}`);
            }
        }

        async function fetchAndAddFactionStratagems() {
            if (!AppState.currentList) {
                alert('Please load an army list first');
                return;
            }
            
            try {
                const factionName = AppState.currentList.faction.toLowerCase().trim();
                const detachmentName = AppState.currentList.detachment || '';
                
                let factionFile = FACTION_FILES[factionName];
                if (!factionFile) {
                    for (const [key, value] of Object.entries(FACTION_FILES)) {
                        if (factionName.includes(key) || key.includes(factionName)) {
                            factionFile = value;
                            break;
                        }
                    }
                }
                
                if (!factionFile) {
                    throw new Error(`Faction "${factionName}" not found. Available: ${Object.keys(FACTION_FILES).join(', ')}`);
                }
                
                const url = GITHUB_BASE_URL + factionFile;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const factionData = await response.json();
                const stratagems = [];
                
                // Extract stratagems from the stratagems array
                // Stratagems are stored in factionData.stratagems
                if (factionData.stratagems && Array.isArray(factionData.stratagems)) {
                    factionData.stratagems.forEach(item => {
                        // Check if matches the current detachment
                        const itemDetachment = item.detachment || '';
                        const matchesDetachment = !detachmentName || 
                            itemDetachment.toLowerCase().includes(detachmentName.toLowerCase()) ||
                            detachmentName.toLowerCase().includes(itemDetachment.toLowerCase());
                        
                        if (matchesDetachment) {
                            // Format phase array to readable text
                            let phaseText = 'Any Phase';
                            if (item.phase && Array.isArray(item.phase)) {
                                const phaseMap = {
                                    'movement': 'Movement Phase',
                                    'shooting': 'Shooting Phase', 
                                    'fight': 'Fight Phase',
                                    'charge': 'Charge Phase',
                                    'command': 'Command Phase'
                                };
                                phaseText = item.phase.map(p => phaseMap[p] || p.charAt(0).toUpperCase() + p.slice(1) + ' Phase').join(', ');
                            } else if (item.when) {
                                phaseText = item.when;
                            }
                            
                            // Build formatted description
                            let formattedDesc = '';
                            if (item.target) {
                                formattedDesc += `TARGET: ${item.target}\n\n`;
                            }
                            formattedDesc += `EFFECT: ${item.effect}` || `EFFECT: ${item.description}` || '';
                            if (item.restrictions && item.restrictions.trim()) {
                                formattedDesc += `\n\nRESTRICTIONS: ${item.restrictions}`;
                            }
                            
                            stratagems.push({
                                name: item.name || 'Unknown Stratagem',
                                cp: item.cost ? `${item.cost}CP` : '?CP',
                                when: phaseText,
                                description: formattedDesc,
                                source: 'Detachment'
                            });
                        }
                    });
                }
                
                // If no stratagems found for specific detachment, ask if user wants all faction stratagems
                if (stratagems.length === 0 && detachmentName) {
                    const useAll = confirm(`No stratagems found for detachment "${detachmentName}". Use all faction stratagems instead?`);
                    if (useAll) {
                        factionData.stratagems.forEach(item => {
                            // Format phase array to readable text
                            let phaseText = 'Any Phase';
                            if (item.phase && Array.isArray(item.phase)) {
                                const phaseMap = {
                                    'movement': 'Movement Phase',
                                    'shooting': 'Shooting Phase', 
                                    'fight': 'Fight Phase',
                                    'charge': 'Charge Phase',
                                    'command': 'Command Phase'
                                };
                                phaseText = item.phase.map(p => phaseMap[p] || p.charAt(0).toUpperCase() + p.slice(1) + ' Phase').join(', ');
                            } else if (item.when) {
                                phaseText = item.when;
                            }
                            
                            // Build formatted description
                            let formattedDesc = '';
                            if (item.target) {
                                formattedDesc += `TARGET: ${item.target}\n\n`;
                            }
                            formattedDesc += `EFFECT: ${item.effect}` || `EFFECT: ${item.description}` || '';
                            if (item.restrictions && item.restrictions.trim()) {
                                formattedDesc += `\n\nRESTRICTIONS: ${item.restrictions}`;
                            }
                            
                            stratagems.push({
                                name: item.name || 'Unknown Stratagem',
                                cp: item.cost ? `${item.cost}CP` : '?CP',
                                when: phaseText,
                                description: formattedDesc,
                                source: 'Detachment'
                            });
                        });
                    }
                }
                
                if (stratagems.length === 0) {
                    throw new Error('No stratagems found');
                }
                
                let addedCount = 0;
                stratagems.forEach(strat => {
                    const ability = {
                        id: generateId(),
                        unitName: `STRATAGEM (${strat.source})`,
                        abilityName: `${strat.name} [${strat.cp}]`,
                        description: `WHEN: ${strat.when}\n\n${strat.description}`,
                        isDetachment: strat.source === 'Detachment',
                        isStratagem: true,
                        isEnemy: checkIfEnemy(strat.description),
                        source: 'stratagem'
                    };
                    
                    AppState.currentList.abilities.push(ability);
                    addedCount++;
                });
                
                AppState.currentList.categorized = categorizeAbilities(AppState.currentList.abilities);
                renderArmyView();
                saveCurrentList();
                
                alert(`Successfully added ${addedCount} Detachment stratagems!`);
                
            } catch (error) {
                console.error('Error fetching faction stratagems:', error);
                alert(`Error fetching faction stratagems: ${error.message}`);
            }
        }

        async function promptDetachmentSelection(detachments) {
            if (!detachments || detachments.length === 0) return null;
            
            const detachmentNames = detachments.map((d, i) => `${i + 1}. ${d.name || 'Detachment ' + (i + 1)}`).join('\n');
            const selection = prompt(`Multiple detachments found. Enter the number:\n\n${detachmentNames}\n\n(or Cancel to abort)`);
            
            if (!selection) return null;
            
            const index = parseInt(selection) - 1;
            if (index >= 0 && index < detachments.length) {
                return detachments[index];
            }
            
            alert('Invalid selection. Please try again.');
            return promptDetachmentSelection(detachments);
        }
    </script>
</body>
</html>